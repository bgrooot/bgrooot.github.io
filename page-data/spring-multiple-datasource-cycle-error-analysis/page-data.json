{"componentChunkName":"component---src-templates-post-tsx","path":"/spring-multiple-datasource-cycle-error-analysis/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"발단\" style=\"position:relative;\"><a href=\"#%EB%B0%9C%EB%8B%A8\" aria-label=\"발단 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>발단</h3>\n<p>내가 만든 프로젝트 중에는 에서는 2개 이상의 DataSource를 사용하고 있는 것이 있다. <code class=\"language-text\">Aurora RDS</code>의 Reader, Writer 엔드포인트에 연결되는 DataSource를 만들고 사용하고 있다. 이 방법에 대한 실효성은 논외로 하고, 그 프로젝트에서 최근에 모종의 이유로 <code class=\"language-text\">Spring Boot Actuator</code>에 대한 의존성을 제외했다. 그런데 모듈을 제외하고 빌드를 수행하니 DataSource Bean의 순환 참조 오류가 발생했다. 문제를 해결하기 위해 우선 HikariConfig Bean을 생성하는 것으로 변경했지만 모듈의 포함 여부가 DataSource의 생성에 영향을 주는 것이 굉장히 의아했기 때문에 그 이유를 분석해 보고 결과를 남겨보려고 한다. </p>\n<h3 id=\"분석\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EC%84%9D\" aria-label=\"분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분석</h3>\n<p>오류 메시지와 사용했던 코드를 간략화한 것은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">The dependencies of some of the beans in the application context form a cycle:\n\n   org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration\n┌─────┐\n|  communityDataSource defined in class path resource [ApplicationConfig.class]\n↑     ↓\n|  writerCommunityDataSource defined in class path resource [ApplicationConfig.class]\n↑     ↓\n|  org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker\n└─────┘</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ApplicationConfig</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"spring.datasource.writer\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DataSource</span> <span class=\"token function\">writerCommunityDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">DataSourceBuilder</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HikariDataSource</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Primary</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DataSource</span> <span class=\"token function\">communityDataSource</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DataSource</span> writerCommunityDataSource<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">RoutingDataSource</span> routingDataSource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RoutingDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> targetDataSources <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        targetDataSources<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WRITER\"</span><span class=\"token punctuation\">,</span> writerCommunityDataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nroutingDataSource<span class=\"token punctuation\">.</span><span class=\"token function\">setTargetDataSources</span><span class=\"token punctuation\">(</span>targetDataSources<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        routingDataSource<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultTargetDataSource</span><span class=\"token punctuation\">(</span>writerCommunityDataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> routingDataSource<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RoutingDataSource</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractRoutingDataSource</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">determineCurrentLookupKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"WRITER\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://www.baeldung.com/circular-dependencies-in-spring\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">순환 참조 에러</a>는 경험한 적이 있기 때문에 어떤 상황에서 발생하는지 알고 있었다. 하지만, <code class=\"language-text\">DataSourceInitializerInvoker</code>가 왜, 그리고 어디서 DataSource를 참조하는지를 몰랐기 때문에 이 클래스의 역할에 대해 알아보았다. Spring 문서에는 다음과 같은 설명이 있다.</p>\n<blockquote>\n<p>InitializingBean#afterPropertiesSet()에서 schema-*.sql을 실행하고 DataSourceSchemaCreatedEvent에서 data-*.sql 스크립트를 실행하여 <code class=\"language-text\">DataSource 초기화를 처리하는 Bean</code>이다.</p>\n</blockquote>\n<p>설명을 적어보면 <code class=\"language-text\">DataSourceInitializerInvoker</code>는 DataSource의 초기화를 위해서 2가지 인터페이스를 구현하여 스키마 생성과 빈 생성 시점에 초기화 할 수 있다. 그리고 <code class=\"language-text\">DataSourceInitializerPostProcessor</code>에 의해서 DataSource 생성 후에 만들어진다. 역할과 생성 시점을 알고 나니 DataSource를 참조할 법도 해 보인다. 좀 더 명확한 이유를 알기위해 에러가 발생하는 곳을 디버깅을 해 보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefaultSingletonBeanRegistry</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SimpleAliasRegistry</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">SingletonBeanRegistry</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">//나머지 코드는 생략.</span>\n    <span class=\"token comment\">//이 메소드 에러 에러 발생.</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">beforeSingletonCreation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inCreationCheckExclusions<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonsCurrentlyInCreation<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCurrentlyInCreationException</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>에러가 발생한 메소드는 Singleton Bean생성 전에 호출되는 콜백으로, 코드에서 보듯이 <code class=\"language-text\">singletonsCurrentlyInCreation</code>라는 Set에 현재 생성하려는 Bean 이름이 있다면 <code class=\"language-text\">BeanCurrentlyInCreationException</code>을 발생시킨다. <code class=\"language-text\">singletonsCurrentlyInCreation</code>에는 아래의 목록을 포함하고 있었고 <code class=\"language-text\">communityDataSource</code>가 이미 존재하기 때문에 에러가 발생한 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0 = \"writerCommunityDataSource\"\n1 = \"communityDataSource\" \n2 = \"entityManagerFactory\"\n3 = \"org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker\"\n4 = \"org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration\"</code></pre></div>\n<p>에러가 난 곳으로부터 trace를 따라가 보니 <code class=\"language-text\">DataSourceInitializerInvoker</code>가 구현하고 있는 <code class=\"language-text\">InitializingBean</code>인터페이스의 <code class=\"language-text\">afterPropertiesSet</code>메소드에서 DataSource를 가져오려고 한 것을 알 수 있었다. 그리고 @Primary 어노테이션에의해 <code class=\"language-text\">communityDataSource</code>가 선택되면서 순환 참조 오류가 발생하게 된 것을 알 수 있었다. 그렇다면 Actuator가 있을 때는 왜 발생하지 않았을까? </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0 = \"writerCommunityDataSource\"\n1 = \"healthContributorRegistry\"\n2 = \"servletEndpointRegistrar\"\n3 = \"dbHealthContributor\"\n4 = \"org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker\"\n5 = \"org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration\"\n6 = \"healthEndpoint\"</code></pre></div>\n<p>Actuator가 포함되었을 때 <code class=\"language-text\">singletonsCurrentlyInCreation</code>에는 위와 같은 항목들이 있었다. 이 목록에서는 <code class=\"language-text\">communityDataSource</code>가 없었기 때문에 에러가 발생하지 않았다. 이 사실로 <code class=\"language-text\">writerCommunityDataSource</code>가 <code class=\"language-text\">communityDataSource</code>가 아닌 다른 어떤 것에 의해 생성되는 것을 알 수 있다. 모듈 포함 여부에 따른 DataSource 생성 플로우는 아래와 같이 진행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//Actuator가 없을 때\n1. communityDataSource\n2. writerCommunityDataSource\n3. DataSourceInitializerInvoker\n4. communityDataSource\n\n//Actuator가 있을 때\n1. ???\n2. writerCommunityDataSource\n3. DataSourceInitializerInvoker\n4. communityDataSource\n5. writerCommunityDataSource</code></pre></div>\n<p>Actuator가 있을 때 5번째 과정에서는 순환 참조 에러가 왜 발생하지 않는지 모호하게 느껴졌었는데 디버깅을 해보니 <code class=\"language-text\">DataSourceInitializerInvoker</code>는 Bean 생성 후 호출되는 메소드이기 때문에 <code class=\"language-text\">communityDataSource</code>에서 의존관계를 찾을 때 정상적으로 찾는다. 생성하고 있는 Bean을 다시 참조하게 될 때만 순환 참조 에러가 발생하게 된다.\n그렇다면 Actuator가 포함되었을 때는 Configuration에서 어노테이션으로 생성되는 시점보다 더 빨리 만들어져야 에러가 발생하지 않을 텐데 DataSource Bean을 생성하는 시점이 어떻게 다른 걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractApplicationContext</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">DefaultResourceLoader</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ConfigurableApplicationContext</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//나머지는 생략</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">refresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalStateException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>startupShutdownMonitor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token function\">postProcessBeanFactory</span><span class=\"token punctuation\">(</span>beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token function\">invokeBeanFactoryPostProcessors</span><span class=\"token punctuation\">(</span>beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token function\">registerBeanPostProcessors</span><span class=\"token punctuation\">(</span>beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token function\">initMessageSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token function\">initApplicationEventMulticaster</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">onRefresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Actuator가 있을 때 생성되는 시점.</span>\n\t\t\t\t<span class=\"token function\">registerListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">finishBeanFactoryInitialization</span><span class=\"token punctuation\">(</span>beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Actuator가 없을 때 생성되는 시점.</span>\n\t\t\t\t<span class=\"token function\">finishRefresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">AbstractApplicationContext</code>에서 빈이 생성되는 시점이 다른 것을 확인할 수 있었는데 Actuator가 포함되지 않았을 때는 <code class=\"language-text\">finishBeanFactoryInitialization</code>메소드에서 <code class=\"language-text\">entityManagerFactory</code>로 DataSource가 생성되고 Actuator가 포함될 때는 그보다 앞션 <code class=\"language-text\">onRefresh</code>메소드의 <code class=\"language-text\">DataSourceHealthContributorAutoConfiguration</code>에서 생성되는 것을 확인할 수 있었다. </p>\n<p>그런데, 테스트하다 보니 스프링 부트 버전을 변경하니 Actuator가 포함되어 있어도 순환 참조 에러가 발생하는 것을 발견했다. 디버깅해보니 <code class=\"language-text\">DataSourceHealthContributorAutoConfiguration</code>는 DataSource를 생성할 때 <code class=\"language-text\">DefaultListableBeanFactory</code>에 정의된 <code class=\"language-text\">beanDefinitionNames</code>에서 DataSource 타입을 찾는데 에러가 발생하는 버전에서는 <code class=\"language-text\">communityDataSource</code>가 먼저 생성되어 아래와 같이 순환 참조 에러가 발생하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. ???\n2. communityDataSource\n3. writerCommunityDataSource\n3. DataSourceInitializerInvoker\n4. communityDataSource</code></pre></div>\n<p>버전에 따라 생성 순서가 바뀌는 이유를 Configuration클래스의 Bean메소드의 메타데이터를 읽는 <code class=\"language-text\">ConfigurationClassParser</code>클래스의 <code class=\"language-text\">retrieveBeanMethodMetadata</code>메소드의 주석에서 찾을 수 있었다.</p>\n<blockquote>\n<p>불행하게도, JVM의 표준 리플렉션은 같은 JVM 에서 동일한 어플리케이션의 다른 실행 간에도 임의의 순서로 메서드를 반환합니다. </p>\n</blockquote>\n<p>이 내용에 따라 Configuration클래스에서 Bean이 선언된 순서를 바꾸면 에러가 나던 버전에서는 에러가 발생하지 않고 에러가 발생하지 않던 버전에서는 에러가 나는 것을 확인 할 수 있었다.</p>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<p>지금까지 조사해본 내용을 요약해보면 아래와 같다.</p>\n<ul>\n<li>DataSource에 의존 관계가 있을 때 <code class=\"language-text\">DataSourceInitializerInvoker</code>에서 선택되는 DataSource에 따라 순환 참조 에러가 발생 할 수 있다. </li>\n<li>Actuator가 포함되었을 때 에러가 나지 않던 이유는 <code class=\"language-text\">DataSourceHealthContributorAutoConfiguration</code>에서 DataSource를 생성해서 순환 참조 에러가 발생하지 않았다.</li>\n<li>하지만, 생성하는 순서에 따라 에러가 발생할 수 있으며 JVM에서 순서는 보장하지 않는다. </li>\n</ul>\n<p>나의 경우에는 이 문제를 해결하기 위해 서두에 언급했듯이 DataSource의 의존관계를 없애고 DataSource를 1개만 생성하는 방법을 사용했다. DataSource를 생성하고 참조했던 이유가 @ConfigurationProperties가 설정된 필드는 변경하지 않고 Bean을 생성해주기 때문이었는데 DataSource를 생성하지 않고 HikariConfig만을 생성해 기존에 하고자 했던 것은 유지하도록 했다. 이제 에러가 발생하는 원인을 알았으니 다른 방법도 충분히 사용할 듯한데 <code class=\"language-text\">DataSourceInitializerInvoker</code>도\n여러 개 정의되어 DataSource를 찾아올 수 있다면 순환 참조 에러가 발생하지 않을 것이다.\n물론 해보지는 않았다.</p>","excerpt":"발단 내가 만든 프로젝트 중에는 에서는 2개 이상의 DataSource를 사용하고 있는 것이 있다. 의 Reader, Writer 엔드포인트에 연결되는 DataSource…","tableOfContents":"<ul>\n<li><a href=\"/spring-multiple-datasource-cycle-error-analysis/#%EB%B0%9C%EB%8B%A8\">발단</a></li>\n<li><a href=\"/spring-multiple-datasource-cycle-error-analysis/#%EB%B6%84%EC%84%9D\">분석</a></li>\n<li><a href=\"/spring-multiple-datasource-cycle-error-analysis/#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>","fields":{"slug":"/spring-multiple-datasource-cycle-error-analysis/"},"frontmatter":{"title":"의존성을 가진 다중 DataSource의 순환 참조 오류 분석","date":"2020년 9월 30일 수요일","tags":["DataSource","DataSourceInitializerInvoker","dependencyCycleError"],"keywords":["Running Out Of Coins.","bgroot"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/spring-multiple-datasource-cycle-error-analysis/","series":[],"lastmod":"0001-01-01"}},"staticQueryHashes":["3649515864","63159454"]}